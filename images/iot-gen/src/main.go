package main

import (
	"bytes"
	"context"
	"io/ioutil"
	"log"
	"os"
	"os/signal"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig"
	"github.com/Shopify/sarama"
	"github.com/urfave/cli"
	"golang.org/x/time/rate"
)

var (
	eventsCount      int
	threadsCount     int
	rateLimit        float64
	templateLocation string
	kafkaTopic       string
	kafkaConn        string
)

func createKafkaProducer(kafkaConn string) (sarama.AsyncProducer, error) {
	config := sarama.NewConfig()
	config.Producer.RequiredAcks = sarama.WaitForLocal
	config.Producer.Compression = sarama.CompressionNone
	producer, err := sarama.NewAsyncProducer(
		strings.Split(kafkaConn, ","), config)

	if err != nil {
		return nil, err
	}

	return producer, nil
}

func produceEvents(producer sarama.AsyncProducer, signals chan os.Signal,
	tpl *template.Template, waitChannel chan struct{}) {
	defer func() {
		waitChannel <- struct{}{}
	}()
	eventsLeft := eventsCount
	ctx := context.Background()
	limiter := rate.NewLimiter(rate.Limit(rateLimit), 1)
ProducerLoop:
	for {
		limiter.Wait(ctx)

		// Generate event
		var event bytes.Buffer
		err := tpl.Execute(&event, nil)
		if err != nil {
			log.Fatalf("Error during template render: %s", err)
		}

		msg := &sarama.ProducerMessage{
			Topic: kafkaTopic,
			Key:   nil,
			Value: sarama.StringEncoder(event.String()),
		}
		select {
		case producer.Input() <- msg:
			log.Println("Event sent")
		case err := <-producer.Errors():
			log.Println("Failed to send an event: ", err)
		case <-signals:
			break ProducerLoop
		}
		if eventsLeft--; eventsLeft == 0 {
			break ProducerLoop
		}
	}
}

func runKafkaProducer(signals chan os.Signal, tpl *template.Template) {
	log.Println("Starting IOT events producer...")
	producer, err := createKafkaProducer(kafkaConn)
	if err != nil {
		log.Fatal("Failed to connect to Kafka: ", err)
	}

	defer func() {
		if err = producer.Close(); err != nil {
			panic(err)
		}
		log.Println("IOT events producer stopped")
	}()

	waitChannel := make(chan struct{})
	for i := 0; i < threadsCount; i++ {
		go produceEvents(producer, signals, tpl, waitChannel)
	}

	// Wait for goroutines completion
	for j := 0; j < threadsCount; j++ {
		<-waitChannel
	}
}

func main() {
	app := cli.NewApp()
	app.Name = "iot-gen"
	app.Usage = "IOT events generator"
	app.Version = "0.1.0"

	app.Flags = []cli.Flag{
		cli.IntFlag{
			Name:        "events-count",
			Value:       -1,
			Usage:       "Number of IOT events to be generated by a single thread (infinite number if -1)",
			Destination: &eventsCount,
			EnvVar:      "IOTGEN_EVENTS_COUNT",
		},
		cli.IntFlag{
			Name:        "threads-count",
			Value:       1,
			Usage:       "Number of threads producing IOT events",
			Destination: &threadsCount,
			EnvVar:      "IOTGEN_THREADS_COUNT",
		},
		cli.Float64Flag{
			Name:        "rate",
			Value:       1,
			Usage:       "Number of events per second that will be generated by a single thread",
			Destination: &rateLimit,
			EnvVar:      "IOTGEN_RATE",
		},
		cli.StringFlag{
			Name:        "template",
			Value:       "templates/template.tpl",
			Usage:       "Template that will be used to generate events",
			Destination: &templateLocation,
			EnvVar:      "IOTGEN_TEMPLATE",
		},
		cli.StringFlag{
			Name:        "kafka-addr",
			Value:       "127.0.0.1:9092",
			Usage:       "Kafka connection string",
			Destination: &kafkaConn,
			EnvVar:      "IOTGEN_KAFKA_ADDR",
		},
		cli.StringFlag{
			Name:        "kafka-topic",
			Value:       "iot-gen-topic",
			Usage:       "Kafka topic",
			Destination: &kafkaTopic,
			EnvVar:      "IOTGEN_KAFKA_TOPIC",
		},
	}
	app.Action = func(c *cli.Context) error {
		signals := make(chan os.Signal, 1)
		signal.Notify(signals, os.Interrupt)
		signal.Notify(signals, os.Kill)

		tpl, err := ioutil.ReadFile(templateLocation)
		if err != nil {
			log.Fatal("Failed to read template: ", err)
		}

		t := template.Must(template.New("event").Funcs(sprig.TxtFuncMap()).Parse(
			string(tpl)))

		runKafkaProducer(signals, t)
		return nil
	}
	app.Run(os.Args)
}
